<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Continuous Reasoning: Scaling the impact of formal methods | Siddharth&#39;s Blog</title>
<meta name="keywords" content="paper review">
<meta name="description" content="Paper link
This paper talks about a static program analysis tool called Infer and its impact at facebook. Infer is based on a program analysis method called continuous reasoning.
Summary This paper describes work in continuous reasoning, where formal reasoning about a (changing) codebase is done in a fashion which mirrors the iterative, continuous model of software development that is increasingly practiced in industry
Given the prevalence of CI/CD pipelines and code review processes, the author suggests that continuous reasoning will allow formal analysis to scale to large codebases if it is integrated into the programmer&#39;s workflow.">
<meta name="author" content="">
<link rel="canonical" href="https://subsid.github.io/posts/2019-02-03-continuous-reasoning/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.998b0f67f24082ae79900674259f89272fd2b7c4eb44357dfcfebcb73156aae1.css" integrity="sha256-mYsPZ/JAgq55kAZ0JZ&#43;JJy/St8TrRDV9/P68tzFWquE=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://subsid.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://subsid.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://subsid.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://subsid.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://subsid.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://subsid.github.io/posts/2019-02-03-continuous-reasoning/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4H9QYNJZV1"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-4H9QYNJZV1', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Continuous Reasoning: Scaling the impact of formal methods" />
<meta property="og:description" content="Paper link
This paper talks about a static program analysis tool called Infer and its impact at facebook. Infer is based on a program analysis method called continuous reasoning.
Summary This paper describes work in continuous reasoning, where formal reasoning about a (changing) codebase is done in a fashion which mirrors the iterative, continuous model of software development that is increasingly practiced in industry
Given the prevalence of CI/CD pipelines and code review processes, the author suggests that continuous reasoning will allow formal analysis to scale to large codebases if it is integrated into the programmer&#39;s workflow." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://subsid.github.io/posts/2019-02-03-continuous-reasoning/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-03T08:36:34-05:00" />
<meta property="article:modified_time" content="2019-02-03T08:36:34-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Continuous Reasoning: Scaling the impact of formal methods"/>
<meta name="twitter:description" content="Paper link
This paper talks about a static program analysis tool called Infer and its impact at facebook. Infer is based on a program analysis method called continuous reasoning.
Summary This paper describes work in continuous reasoning, where formal reasoning about a (changing) codebase is done in a fashion which mirrors the iterative, continuous model of software development that is increasingly practiced in industry
Given the prevalence of CI/CD pipelines and code review processes, the author suggests that continuous reasoning will allow formal analysis to scale to large codebases if it is integrated into the programmer&#39;s workflow."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://subsid.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Continuous Reasoning: Scaling the impact of formal methods",
      "item": "https://subsid.github.io/posts/2019-02-03-continuous-reasoning/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Continuous Reasoning: Scaling the impact of formal methods",
  "name": "Continuous Reasoning: Scaling the impact of formal methods",
  "description": "Paper link\nThis paper talks about a static program analysis tool called Infer and its impact at facebook. Infer is based on a program analysis method called continuous reasoning.\nSummary This paper describes work in continuous reasoning, where formal reasoning about a (changing) codebase is done in a fashion which mirrors the iterative, continuous model of software development that is increasingly practiced in industry\nGiven the prevalence of CI/CD pipelines and code review processes, the author suggests that continuous reasoning will allow formal analysis to scale to large codebases if it is integrated into the programmer\u0026#39;s workflow.",
  "keywords": [
    "paper review"
  ],
  "articleBody": " Paper link\nThis paper talks about a static program analysis tool called Infer and its impact at facebook. Infer is based on a program analysis method called continuous reasoning.\nSummary This paper describes work in continuous reasoning, where formal reasoning about a (changing) codebase is done in a fashion which mirrors the iterative, continuous model of software development that is increasingly practiced in industry\nGiven the prevalence of CI/CD pipelines and code review processes, the author suggests that continuous reasoning will allow formal analysis to scale to large codebases if it is integrated into the programmer's workflow. Infer is a static analysis tool for analyzing C, C++, Java, and Object-C code. Its written in OCaml. Since it runs on code diffs (rather than rebuilding the entire codebase), it is quite fast - order of low tens of minutes. This makes it a compelling tool for developers, as they get feedback during code reviews. (vs having a bug board for these errors)\nOne of the main reasons why Infer is fast is due to Automatic Composability.\nThe technical feature which enables Infer’s diff-time deployment is compositionality. The idea of compositionality comes from language semantics: a semantics is compositional if the meaning of a complex phrase is defined in terms of the meanings of its parts and a means of combining them.\nThis idea is transferred to software analysis and is known as Compositional Analysis. By definition, compositional analysis does not rely on the whole program.\nCompositional Analysis: an automatic program analysis is compositional if the analysis result of a composite program is defined in terms of the analysis results of its parts and a means of combining them.\nWhy is it better to do this, as opposed to running a sophisticated verification tool independent of development?\nROFL ((Report Only Failure List)) Episode At Facebook, an earlier version of Infer was deployed as a batch process running once every night or so. The tool reported a bunch of errors and these were then manually assigned to appropriate developers. As it turned out, none of these issues were prioritized by the devs. This is because of 2 main reasons:\nMental effort of context switch It is hard for programmers to context switch to some old commit and work on it. Relevance Assigning an issue to the right person is a non-trivial task. Both of these reasons are addressed by a diff based analysis approach. The Infer engine acts as a bot reviewer that gives the developer meaningful comments during the review process. The Impact of this system was enormous at facebook - tens of thousands of bugs reported by Infer were fixed.\nA contrasting analysis tool, that relies on formal verification is s2n by Amazon. S2n does a full-fledged formal verification but does not scale to large codebases.\nReporting As mentioned before with ROFL, what and when to report is important. The following are some reporting possibilities:\nLean reporting of only new errors only on changed files is Infer’s default at diff time. It is a low friction deployment: it avoids reporting pre-existing issues to an author of a diff, which typically will not be relevant to the diff. It supports the first axiom of industrial static analysis: Don’t spam the developer. Bulky reporting can, when run on a large legacy codebase, result in numerous pre-existing issues being reported. Sometimes these can be overwhelming, and irrelevant to the diff author, so care is needed in this reporting mode. (With Infer, we are experimenting with it for certain bug types and certain projects.) Cautious reporting fits well with periodic global analyzer runs on an entire codebase, as opposed to at diff time. It has been used by Coverity, and versions of it are used for both static and dynamic analysis at Facebook. Clean is used for deployments that seek to keep a codebase entirely free of certain issues. The Amazon s2n effort uses this deployment, Infer has used it with the source code of the Buck build system, and it is commonly used with type systems. Though automatic composability is hard, it may be worth spending time on improving continuous analysis, due to its scalability and impact.\nBlog:Continous Reasoning Blog Paper Review\n",
  "wordCount" : "698",
  "inLanguage": "en",
  "datePublished": "2019-02-03T08:36:34-05:00",
  "dateModified": "2019-02-03T08:36:34-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://subsid.github.io/posts/2019-02-03-continuous-reasoning/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Siddharth's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://subsid.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://subsid.github.io/" accesskey="h" title="Siddharth&#39;s Blog (Alt + H)">Siddharth&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://subsid.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://subsid.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://subsid.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://subsid.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://subsid.github.io/index.xml" title="RSS">
                    <span>RSS</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Continuous Reasoning: Scaling the impact of formal methods
    </h1>
    <div class="post-meta"><span title='2019-02-03 08:36:34 -0500 EST'>February 3, 2019</span>

</div>
  </header> 
  <div class="post-content">
<div class="comment-block">
</div>
<p>
<a href="https://research.facebook.com/publications/continuous-reasoning-scaling-the-impact-of-formal-methods">Paper link</a></p>
<p>
This paper talks about a <a href="https://en.wikipedia.org/wiki/Static_program_analysis">static program analysis</a> tool called <a href="https://github.com/facebook/infer">Infer</a> and its impact at facebook. <em>Infer</em> is based on a program analysis method called continuous reasoning.</p>
<div id="outline-container-headline-1" class="outline-3">
<h3 id="headline-1">
Summary
</h3>
<div id="outline-text-headline-1" class="outline-text-3">
<p>This paper describes work in continuous reasoning, where formal reasoning about a (changing) codebase is done in a fashion which mirrors the iterative, continuous model of software development that is increasingly practiced in industry</p>
<p>
Given the prevalence of CI/CD pipelines and code review processes, the author suggests that continuous reasoning will allow formal analysis to scale to large codebases if it is integrated into the programmer&#39;s workflow. Infer is a static analysis tool for analyzing C, C++, Java, and Object-C code. Its written in OCaml. Since it runs on code diffs (rather than rebuilding the entire codebase), it is quite fast - order of low tens of minutes. This makes it a compelling tool for developers, as they get feedback during code reviews. (vs having a bug board for these errors)</p>
<p>
One of the main reasons why Infer is fast is due to <strong>Automatic Composability</strong>.</p>
<blockquote>
<p>The technical feature which enables Infer’s diff-time deployment is compositionality. The idea of compositionality comes from language semantics: a semantics is compositional if the meaning of a complex phrase is defined in terms of the meanings of its parts and a means of combining them.</p>
</blockquote>
<p>
This idea is transferred to software analysis and is known as <strong>Compositional Analysis</strong>. By definition, compositional analysis does not rely on the whole program.</p>
<blockquote>
<p>Compositional Analysis: an automatic program analysis is compositional if the analysis result of a composite program is defined in terms of the analysis results of its parts and a means of combining them.</p>
</blockquote>
<p>
<em>Why is it better to do this, as opposed to running a sophisticated verification tool independent of development?</em></p>
<p>
<strong><strong>ROFL ((Report Only Failure List)) Episode</strong></strong> At Facebook, an earlier version of Infer was deployed as a batch process running once every night or so. The tool reported a bunch of errors and these were then manually assigned to appropriate developers. As it turned out, none of these issues were prioritized by the devs. This is because of 2 main reasons:</p>
<ul>
<li><strong>Mental effort of context switch</strong> It is hard for programmers to context switch to some old commit and work on it.</li>
<li><strong>Relevance</strong> Assigning an issue to the right person is a non-trivial task.</li>
</ul>
<p>Both of these reasons are addressed by a diff based analysis approach. The Infer engine acts as a bot reviewer that gives the developer meaningful comments during the review process. The Impact of this system was enormous at facebook - tens of thousands of bugs reported by Infer were fixed.</p>
<p>
A contrasting analysis tool, that relies on formal verification is <a href="https://d1.awsstatic.com/Security/pdfs/Continuous_Formal_Verification_Of_Amazon_s2n.pdf">s2n by Amazon</a>. S2n does a full-fledged formal verification but does not scale to large codebases.</p>
<p>
<figure>
    <img loading="lazy" src="/img/s2n-vs-infer.png"/> 
</figure>
</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
Reporting
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<p>
As mentioned before with ROFL, what and when to report is important. The following are some reporting possibilities:</p>
<ul>
<li><strong>Lean</strong> reporting of only new errors only on changed files is Infer’s default at diff time. It is a low friction deployment: it avoids reporting pre-existing issues to an author of a diff, which typically will not be relevant to the diff. It supports the first axiom of industrial static analysis: Don’t spam the developer.</li>
<li><strong>Bulky</strong> reporting can, when run on a large legacy codebase, result in numerous pre-existing issues being reported. Sometimes these can be overwhelming, and irrelevant to the diff author, so care is needed in this reporting mode. (With Infer, we are experimenting with it for certain bug types and certain projects.)</li>
<li><strong>Cautious</strong> reporting fits well with periodic global analyzer runs on an entire codebase, as opposed to at diff time. It has been used by Coverity, and versions of it are used for both static and dynamic analysis at Facebook.</li>
<li><strong>Clean</strong> is used for deployments that seek to keep a codebase entirely free of certain issues. The Amazon s2n effort uses this deployment, Infer has used it with the source code of the Buck build system, and it is commonly used with type systems.</li>
</ul>
<p>Though <strong>automatic composability</strong> is hard, it may be worth spending time on improving continuous analysis, due to its scalability and impact.</p>
</div>
</div>
<div id="outline-container-hideroamtags" class="outline-2">
<h2 id="hideroamtags">
Blog:Continous Reasoning
</h2>
<div id="outline-text-hideroamtags" class="outline-text-2">
<p>
<a href="id:b5ca1c71-fca2-4494-abc0-d555f0e9986f">Blog</a> <a href="id:28add7ce-3af3-49a8-8361-c9aaef15bca7">Paper Review</a></p>
</div>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://subsid.github.io/tags/paper-review/">Paper Review</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://subsid.github.io/">Siddharth&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>


<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
